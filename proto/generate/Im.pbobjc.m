// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Im.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ImRoot

@implementation ImRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ImRoot_FileDescriptor

static GPBFileDescriptor *ImRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"im"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum IM_HEADER

GPBEnumDescriptor *IM_HEADER_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Firster\000CSPing\000SCPing\000SCError\000CSInfor\000SC"
        "Infor\000SCUserLogined\000CSSend\000SCSend\000SCSend"
        "Info\000SCOnline\000SCAddOnline\000SCSignOut\000SCOf"
        "flineMessage\000";
    static const int32_t values[] = {
        IM_HEADER_Firster,
        IM_HEADER_CSPing,
        IM_HEADER_SCPing,
        IM_HEADER_SCError,
        IM_HEADER_CSInfor,
        IM_HEADER_SCInfor,
        IM_HEADER_SCUserLogined,
        IM_HEADER_CSSend,
        IM_HEADER_SCSend,
        IM_HEADER_SCSendInfo,
        IM_HEADER_SCOnline,
        IM_HEADER_SCAddOnline,
        IM_HEADER_SCSignOut,
        IM_HEADER_SCOfflineMessage,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(IM_HEADER)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:IM_HEADER_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL IM_HEADER_IsValidValue(int32_t value__) {
  switch (value__) {
    case IM_HEADER_Firster:
    case IM_HEADER_CSPing:
    case IM_HEADER_SCPing:
    case IM_HEADER_SCError:
    case IM_HEADER_CSInfor:
    case IM_HEADER_SCInfor:
    case IM_HEADER_SCUserLogined:
    case IM_HEADER_CSSend:
    case IM_HEADER_SCSend:
    case IM_HEADER_SCSendInfo:
    case IM_HEADER_SCOnline:
    case IM_HEADER_SCAddOnline:
    case IM_HEADER_SCSignOut:
    case IM_HEADER_SCOfflineMessage:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - C_S_Ping

@implementation C_S_Ping


typedef struct C_S_Ping__storage_ {
  uint32_t _has_storage_[1];
} C_S_Ping__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[C_S_Ping class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(C_S_Ping__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - S_C_Ping

@implementation S_C_Ping


typedef struct S_C_Ping__storage_ {
  uint32_t _has_storage_[1];
} S_C_Ping__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[S_C_Ping class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(S_C_Ping__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - S_C_error

@implementation S_C_error

@dynamic code;
@dynamic msg;

typedef struct S_C_error__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  NSString *msg;
} S_C_error__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = S_C_error_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(S_C_error__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = S_C_error_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(S_C_error__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[S_C_error class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(S_C_error__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - C_S_infor

@implementation C_S_infor

@dynamic code;
@dynamic msg;
@dynamic targetUserId;
@dynamic callback;

typedef struct C_S_infor__storage_ {
  uint32_t _has_storage_[1];
  NSString *code;
  NSString *msg;
  NSString *targetUserId;
  NSString *callback;
} C_S_infor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = C_S_infor_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(C_S_infor__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = C_S_infor_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(C_S_infor__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetUserId",
        .dataTypeSpecific.className = NULL,
        .number = C_S_infor_FieldNumber_TargetUserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(C_S_infor__storage_, targetUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "callback",
        .dataTypeSpecific.className = NULL,
        .number = C_S_infor_FieldNumber_Callback,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(C_S_infor__storage_, callback),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[C_S_infor class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(C_S_infor__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - S_C_infor

@implementation S_C_infor

@dynamic code;
@dynamic msg;
@dynamic other;
@dynamic callback;
@dynamic callbackType;

typedef struct S_C_infor__storage_ {
  uint32_t _has_storage_[1];
  NSString *code;
  NSString *msg;
  NSString *other;
  NSString *callback;
  NSString *callbackType;
} S_C_infor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = S_C_infor_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(S_C_infor__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = S_C_infor_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(S_C_infor__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "other",
        .dataTypeSpecific.className = NULL,
        .number = S_C_infor_FieldNumber_Other,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(S_C_infor__storage_, other),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "callback",
        .dataTypeSpecific.className = NULL,
        .number = S_C_infor_FieldNumber_Callback,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(S_C_infor__storage_, callback),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "callbackType",
        .dataTypeSpecific.className = NULL,
        .number = S_C_infor_FieldNumber_CallbackType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(S_C_infor__storage_, callbackType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[S_C_infor class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(S_C_infor__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - msgContent

@implementation msgContent

@dynamic content;
@dynamic imageURL;
@dynamic fileURL;
@dynamic time;
@dynamic timestamp;

typedef struct msgContent__storage_ {
  uint32_t _has_storage_[1];
  NSData *content;
  NSString *imageURL;
  NSString *fileURL;
  NSString *time;
  NSString *timestamp;
} msgContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = msgContent_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(msgContent__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "imageURL",
        .dataTypeSpecific.className = NULL,
        .number = msgContent_FieldNumber_ImageURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(msgContent__storage_, imageURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileURL",
        .dataTypeSpecific.className = NULL,
        .number = msgContent_FieldNumber_FileURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(msgContent__storage_, fileURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = msgContent_FieldNumber_Time,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(msgContent__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = msgContent_FieldNumber_Timestamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(msgContent__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[msgContent class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(msgContent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\005\241!!\000\003\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - C_S_Send_msg

@implementation C_S_Send_msg

@dynamic msgId;
@dynamic userId;
@dynamic groupId;
@dynamic type;
@dynamic clientMsgId;
@dynamic sessionId;
@dynamic hasMessage, message;

typedef struct C_S_Send_msg__storage_ {
  uint32_t _has_storage_[1];
  int32_t userId;
  int32_t groupId;
  uint32_t type;
  NSString *msgId;
  NSString *clientMsgId;
  NSString *sessionId;
  msgContent *message;
} C_S_Send_msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = C_S_Send_msg_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(C_S_Send_msg__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = C_S_Send_msg_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(C_S_Send_msg__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = C_S_Send_msg_FieldNumber_GroupId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(C_S_Send_msg__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = C_S_Send_msg_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(C_S_Send_msg__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "clientMsgId",
        .dataTypeSpecific.className = NULL,
        .number = C_S_Send_msg_FieldNumber_ClientMsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(C_S_Send_msg__storage_, clientMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = C_S_Send_msg_FieldNumber_SessionId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(C_S_Send_msg__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(msgContent),
        .number = C_S_Send_msg_FieldNumber_Message,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(C_S_Send_msg__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[C_S_Send_msg class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(C_S_Send_msg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\007G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - S_C_Send_msg

@implementation S_C_Send_msg

@dynamic msgId;
@dynamic sessionId;
@dynamic userId;
@dynamic sender;
@dynamic targetGroupId;
@dynamic targetUserId;
@dynamic type;
@dynamic clientMsgId;
@dynamic state;
@dynamic hasMessage, message;

typedef struct S_C_Send_msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sender;
  uint32_t type;
  uint32_t state;
  NSString *msgId;
  NSString *sessionId;
  NSString *userId;
  NSString *targetGroupId;
  NSString *targetUserId;
  NSString *clientMsgId;
  msgContent *message;
} S_C_Send_msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_msg_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(S_C_Send_msg__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_msg_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(S_C_Send_msg__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_msg_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(S_C_Send_msg__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_msg_FieldNumber_Sender,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(S_C_Send_msg__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "targetGroupId",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_msg_FieldNumber_TargetGroupId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(S_C_Send_msg__storage_, targetGroupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetUserId",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_msg_FieldNumber_TargetUserId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(S_C_Send_msg__storage_, targetUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_msg_FieldNumber_Type,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(S_C_Send_msg__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "clientMsgId",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_msg_FieldNumber_ClientMsgId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(S_C_Send_msg__storage_, clientMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_msg_FieldNumber_State,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(S_C_Send_msg__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(msgContent),
        .number = S_C_Send_msg_FieldNumber_Message,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(S_C_Send_msg__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[S_C_Send_msg class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(S_C_Send_msg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\nG\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - S_C_Send_Info

@implementation S_C_Send_Info

@dynamic msgId;
@dynamic state;
@dynamic content;
@dynamic clientMsgId;

typedef struct S_C_Send_Info__storage_ {
  uint32_t _has_storage_[1];
  int32_t state;
  NSString *msgId;
  NSString *content;
  NSString *clientMsgId;
} S_C_Send_Info__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_Info_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(S_C_Send_Info__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_Info_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(S_C_Send_Info__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_Info_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(S_C_Send_Info__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientMsgId",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Send_Info_FieldNumber_ClientMsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(S_C_Send_Info__storage_, clientMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[S_C_Send_Info class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(S_C_Send_Info__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - offlineMessage

@implementation offlineMessage

@dynamic userId;
@dynamic sessionId;
@dynamic infoArray, infoArray_Count;

typedef struct offlineMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t userId;
  NSString *sessionId;
  NSMutableArray *infoArray;
} offlineMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = offlineMessage_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(offlineMessage__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = offlineMessage_FieldNumber_SessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(offlineMessage__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "infoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(S_C_Send_msg),
        .number = offlineMessage_FieldNumber_InfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(offlineMessage__storage_, infoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[offlineMessage class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(offlineMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - S_C_Offline_Message

@implementation S_C_Offline_Message

@dynamic offlineArray, offlineArray_Count;

typedef struct S_C_Offline_Message__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *offlineArray;
} S_C_Offline_Message__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offlineArray",
        .dataTypeSpecific.className = GPBStringifySymbol(offlineMessage),
        .number = S_C_Offline_Message_FieldNumber_OfflineArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(S_C_Offline_Message__storage_, offlineArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[S_C_Offline_Message class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(S_C_Offline_Message__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - online

@implementation online

@dynamic userId;
@dynamic type;

typedef struct online__storage_ {
  uint32_t _has_storage_[1];
  int32_t userId;
  uint32_t type;
} online__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = online_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(online__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = online_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(online__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[online class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(online__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - S_C_Online

@implementation S_C_Online

@dynamic onlineArray, onlineArray_Count;

typedef struct S_C_Online__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *onlineArray;
} S_C_Online__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onlineArray",
        .dataTypeSpecific.className = GPBStringifySymbol(online),
        .number = S_C_Online_FieldNumber_OnlineArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(S_C_Online__storage_, onlineArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[S_C_Online class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(S_C_Online__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000Online\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - S_C_Add_Online

@implementation S_C_Add_Online

@dynamic userId;

typedef struct S_C_Add_Online__storage_ {
  uint32_t _has_storage_[1];
  int32_t userId;
} S_C_Add_Online__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Add_Online_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(S_C_Add_Online__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[S_C_Add_Online class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(S_C_Add_Online__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - S_C_Sign_Out

@implementation S_C_Sign_Out

@dynamic userId;

typedef struct S_C_Sign_Out__storage_ {
  uint32_t _has_storage_[1];
  int32_t userId;
} S_C_Sign_Out__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = S_C_Sign_Out_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(S_C_Sign_Out__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[S_C_Sign_Out class]
                                     rootClass:[ImRoot class]
                                          file:ImRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(S_C_Sign_Out__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
